

#include "uart.h"

BOOL UART_Ready = 0;

#if defined(__GNUC__) && defined(__GNUC_MINOR__)

#if( UART_INTERRUPT_ENABLE )
static volatile char UART_TxBuf[UART_TX_BUFFER_SIZE];
static volatile char UART_RxBuf[UART_RX_BUFFER_SIZE];
static volatile char UART_TxHead;
static volatile char UART_TxTail;
static volatile char UART_RxHead;
static volatile char UART_RxTail;
static volatile char UART_LastRxError;
#endif

#if defined( ATMEGA_USART1 )
static volatile char UART1_TxBuf[UART_TX_BUFFER_SIZE];
static volatile char UART1_RxBuf[UART_RX_BUFFER_SIZE];
static volatile char UART1_TxHead;
static volatile char UART1_TxTail;
static volatile char UART1_RxHead;
static volatile char UART1_RxTail;
static volatile char UART1_LastRxError;
#endif


void uart_init(u32 baud)
{
  unsigned int baudrate;

  switch(baud)
  {
    case 1200:
    case 2400:
    case 9600:
    case 115200: break;
    default: baud  = UART_DEFAULT_BAUD_RATE;
  }

  baudrate = UART_BAUD_SELECT(baud,F_CPU);

#if( UART_INTERRUPT_ENABLE )
  UART_TxHead = 0;
  UART_TxTail = 0;
  UART_RxHead = 0;
  UART_RxTail = 0;
#endif


#if defined(AT90_UART)
  /* set baud rate */
  UBRR = (unsigned char)baudrate;

  /* enable UART receiver and transmmitter and receive complete interrupt */
  UART0_CONTROL = _BV(RXCIE)|_BV(RXEN)|_BV(TXEN);

#elif defined (ATMEGA_USART)

  // disable usart when setup
  UART0_CONTROL = 0x00;

  /* Set baud rate */
  if( baudrate & 0x8000 )
  {
    UART0_STATUS = (1<<U2X);  //Enable 2x speed 
    baudrate &= ~0x8000;
  }
  UBRRH = (unsigned char)(baudrate>>8);
  UBRRL = (unsigned char) baudrate;

  //test
  UBRRH = 0x00;
  UBRRL = 0x33;
   
  /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
  #ifdef URSEL
  UCSRC = (1<<URSEL)|(3<<UCSZ0);
  #else
  UCSRC = (3<<UCSZ0);
  #endif 
    
  // Enable USART receive complete interrupt
  #if( UART_INTERRUPT_ENABLE )
  UART0_CONTROL |= _BV(RXCIE);
  #endif
    
  /* Enable USART receiver and transmitter */
  UART0_CONTROL = (1<<RXEN)|(1<<TXEN);

#elif defined (ATMEGA_USART0)
  /* Set baud rate */
  if ( baudrate & 0x8000 ) 
  {
    UART0_STATUS = (1<<U2X0);  //Enable 2x speed 
    baudrate &= ~0x8000;
  }
  UBRR0H = (unsigned char)(baudrate>>8);
  UBRR0L = (unsigned char) baudrate;

  /* Enable USART receiver and transmitter and receive complete interrupt */
  UART0_CONTROL = _BV(RXCIE0)|(1<<RXEN0)|(1<<TXEN0);
    
  /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
  #ifdef URSEL0
  UCSR0C = (1<<URSEL0)|(3<<UCSZ00);
  #else
  UCSR0C = (3<<UCSZ00);
  #endif 

#elif defined (ATMEGA_UART)
  /* set baud rate */
  if ( baudrate & 0x8000 ) 
  {
    UART0_STATUS = (1<<U2X);  //Enable 2x speed 
    baudrate &= ~0x8000;
  }
  UBRRHI = (unsigned char)(baudrate>>8);
  UBRR   = (unsigned char) baudrate;

  /* Enable UART receiver and transmitter and receive complete interrupt */
  UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);

#endif

}

void uart_putchar(int c)
{
  uart_putc((char)(c & 0x00ff));
}

void uart_putc(char data)
{
#if( UART_INTERRUPT_ENABLE )
  char tmphead;
  tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
    
  while ( tmphead == UART_TxTail ){
  }
    
  UART_TxBuf[UART_TxHead] = data;
  UART_TxHead = tmphead;

  /* enable UDRE interrupt */
  UART0_CONTROL |= _BV(UART0_UDRIE);
#else
  while(!(UART0_CONTROL & (1<<UDRE))) ;
  UART0_DATA = data;
#endif
  
}

char uart_getc(void)
{
  return 0;
}


#if( UART_INTERRUPT_ENABLE )

/**********************************************************
Function: UART Receive Complete interrupt
Purpose:  called when the UART has received a character
**********************************************************/
ISR(UART0_RECEIVE_INTERRUPT)
{
  unsigned char tmphead;
  unsigned char data;
  unsigned char usr;
  unsigned char lastRxError;
 
  /* read UART status register and UART data register */ 
  usr  = UART0_STATUS;
  data = UART0_DATA;
    
#if defined(AT90_UART )
  lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#elif defined(ATMEGA_USART )
  lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#elif defined( ATMEGA_USART0 )
  lastRxError = (usr & (_BV(FE0)|_BV(DOR0)) );
#elif defined ( ATMEGA_UART )
  lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#endif
        
  /* calculate buffer index */ 
  tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
    
  if ( tmphead == UART_RxTail ) {
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
  }else{
        /* store new index */
        UART_RxHead = tmphead;
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
  }
  UART_LastRxError = lastRxError;   
}


/*****************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
*****************************************************************/
ISR(UART0_TRANSMIT_INTERRUPT)
{
  char tmptail;
   
  if ( UART_TxHead != UART_TxTail) {
        /* get one byte from buffer and write it to UART */
        UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */

        /* calculate and store new buffer index */
        tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
        UART_TxTail = tmptail;
  }else{
        /* tx buffer empty, disable UDRE interrupt */
        UART0_CONTROL &= ~_BV(UART0_UDRIE);
  }
}

#endif




#elif defined (STM32F10X_LD) || defined (STM32F10X_LD_VL) || \
      defined (STM32F10X_MD) || defined (STM32F10X_MD_VL) || \
      defined (STM32F10X_HD) || defined (STM32F10X_HD_VL) || \
      defined (STM32F10X_XL) || defined (STM32F10X_CL)

void uart_Init(void)
{
  USART_InitTypeDef UASRT_Initstructure;
  GPIO_InitTypeDef GPIO_InitStructure;
	
  UASRT_Initstructure.USART_BaudRate = 9600;
  UASRT_Initstructure.USART_WordLength = USART_WordLength_8b;
  UASRT_Initstructure.USART_StopBits = USART_StopBits_1;
  UASRT_Initstructure.USART_Parity = USART_Parity_No;
  UASRT_Initstructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  UASRT_Initstructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
	
  //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_USART1, ENABLE);
	
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
	
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
	
	
  USART_Init(USART1, &UASRT_Initstructure);
	
  /* Enable USART1 Receive and Transmit interrupts */
  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); 

  USART_Cmd(USART1, ENABLE);
  UART_Ready = 1;
	
}	


void uart_putchar(int c)
{
  while(USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET)
  {
  }
  USART_SendData(USART1,c);
}


#endif

void uart_puts(const char * str)
{
  while(*str != '\0')
  {
    uart_putchar(*str++);
  }
}

